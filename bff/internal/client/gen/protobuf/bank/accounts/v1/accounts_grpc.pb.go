// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: bank/accounts/v1/accounts.proto

package accountsv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CustomersService_CreateCustomer_FullMethodName = "/bank.accounts.v1.CustomersService/CreateCustomer"
	CustomersService_PatchCustomer_FullMethodName  = "/bank.accounts.v1.CustomersService/PatchCustomer"
)

// CustomersServiceClient is the client API for CustomersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CustomersServiceClient interface {
	// POST /customers
	CreateCustomer(ctx context.Context, in *CreateCustomerRequest, opts ...grpc.CallOption) (*CreateCustomerResponse, error)
	// PATCH /customers/{id}
	PatchCustomer(ctx context.Context, in *PatchCustomerRequest, opts ...grpc.CallOption) (*PatchCustomerResponse, error)
}

type customersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCustomersServiceClient(cc grpc.ClientConnInterface) CustomersServiceClient {
	return &customersServiceClient{cc}
}

func (c *customersServiceClient) CreateCustomer(ctx context.Context, in *CreateCustomerRequest, opts ...grpc.CallOption) (*CreateCustomerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCustomerResponse)
	err := c.cc.Invoke(ctx, CustomersService_CreateCustomer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customersServiceClient) PatchCustomer(ctx context.Context, in *PatchCustomerRequest, opts ...grpc.CallOption) (*PatchCustomerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchCustomerResponse)
	err := c.cc.Invoke(ctx, CustomersService_PatchCustomer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomersServiceServer is the server API for CustomersService service.
// All implementations must embed UnimplementedCustomersServiceServer
// for forward compatibility.
type CustomersServiceServer interface {
	// POST /customers
	CreateCustomer(context.Context, *CreateCustomerRequest) (*CreateCustomerResponse, error)
	// PATCH /customers/{id}
	PatchCustomer(context.Context, *PatchCustomerRequest) (*PatchCustomerResponse, error)
	mustEmbedUnimplementedCustomersServiceServer()
}

// UnimplementedCustomersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCustomersServiceServer struct{}

func (UnimplementedCustomersServiceServer) CreateCustomer(context.Context, *CreateCustomerRequest) (*CreateCustomerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCustomer not implemented")
}
func (UnimplementedCustomersServiceServer) PatchCustomer(context.Context, *PatchCustomerRequest) (*PatchCustomerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PatchCustomer not implemented")
}
func (UnimplementedCustomersServiceServer) mustEmbedUnimplementedCustomersServiceServer() {}
func (UnimplementedCustomersServiceServer) testEmbeddedByValue()                          {}

// UnsafeCustomersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CustomersServiceServer will
// result in compilation errors.
type UnsafeCustomersServiceServer interface {
	mustEmbedUnimplementedCustomersServiceServer()
}

func RegisterCustomersServiceServer(s grpc.ServiceRegistrar, srv CustomersServiceServer) {
	// If the following call panics, it indicates UnimplementedCustomersServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CustomersService_ServiceDesc, srv)
}

func _CustomersService_CreateCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomersServiceServer).CreateCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomersService_CreateCustomer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomersServiceServer).CreateCustomer(ctx, req.(*CreateCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomersService_PatchCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomersServiceServer).PatchCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomersService_PatchCustomer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomersServiceServer).PatchCustomer(ctx, req.(*PatchCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CustomersService_ServiceDesc is the grpc.ServiceDesc for CustomersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CustomersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bank.accounts.v1.CustomersService",
	HandlerType: (*CustomersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCustomer",
			Handler:    _CustomersService_CreateCustomer_Handler,
		},
		{
			MethodName: "PatchCustomer",
			Handler:    _CustomersService_PatchCustomer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bank/accounts/v1/accounts.proto",
}

const (
	AccountsService_ListAccounts_FullMethodName       = "/bank.accounts.v1.AccountsService/ListAccounts"
	AccountsService_CreateAccount_FullMethodName      = "/bank.accounts.v1.AccountsService/CreateAccount"
	AccountsService_GetAccountBalances_FullMethodName = "/bank.accounts.v1.AccountsService/GetAccountBalances"
	AccountsService_PatchAccountLimits_FullMethodName = "/bank.accounts.v1.AccountsService/PatchAccountLimits"
	AccountsService_GetAccountByNumber_FullMethodName = "/bank.accounts.v1.AccountsService/GetAccountByNumber"
)

// AccountsServiceClient is the client API for AccountsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountsServiceClient interface {
	// GET /accounts?customer_id=...
	ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	// POST /accounts
	CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error)
	// GET /accounts/{id}/balances
	GetAccountBalances(ctx context.Context, in *GetAccountBalancesRequest, opts ...grpc.CallOption) (*GetAccountBalancesResponse, error)
	// PATCH /accounts/{id}/limits
	PatchAccountLimits(ctx context.Context, in *PatchAccountLimitsRequest, opts ...grpc.CallOption) (*PatchAccountLimitsResponse, error)
	GetAccountByNumber(ctx context.Context, in *GetAccountByNumberRequest, opts ...grpc.CallOption) (*GetAccountByNumberResponse, error)
}

type accountsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountsServiceClient(cc grpc.ClientConnInterface) AccountsServiceClient {
	return &accountsServiceClient{cc}
}

func (c *accountsServiceClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, AccountsService_ListAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsServiceClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAccountResponse)
	err := c.cc.Invoke(ctx, AccountsService_CreateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsServiceClient) GetAccountBalances(ctx context.Context, in *GetAccountBalancesRequest, opts ...grpc.CallOption) (*GetAccountBalancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountBalancesResponse)
	err := c.cc.Invoke(ctx, AccountsService_GetAccountBalances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsServiceClient) PatchAccountLimits(ctx context.Context, in *PatchAccountLimitsRequest, opts ...grpc.CallOption) (*PatchAccountLimitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchAccountLimitsResponse)
	err := c.cc.Invoke(ctx, AccountsService_PatchAccountLimits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsServiceClient) GetAccountByNumber(ctx context.Context, in *GetAccountByNumberRequest, opts ...grpc.CallOption) (*GetAccountByNumberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAccountByNumberResponse)
	err := c.cc.Invoke(ctx, AccountsService_GetAccountByNumber_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountsServiceServer is the server API for AccountsService service.
// All implementations must embed UnimplementedAccountsServiceServer
// for forward compatibility.
type AccountsServiceServer interface {
	// GET /accounts?customer_id=...
	ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error)
	// POST /accounts
	CreateAccount(context.Context, *CreateAccountRequest) (*CreateAccountResponse, error)
	// GET /accounts/{id}/balances
	GetAccountBalances(context.Context, *GetAccountBalancesRequest) (*GetAccountBalancesResponse, error)
	// PATCH /accounts/{id}/limits
	PatchAccountLimits(context.Context, *PatchAccountLimitsRequest) (*PatchAccountLimitsResponse, error)
	GetAccountByNumber(context.Context, *GetAccountByNumberRequest) (*GetAccountByNumberResponse, error)
	mustEmbedUnimplementedAccountsServiceServer()
}

// UnimplementedAccountsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountsServiceServer struct{}

func (UnimplementedAccountsServiceServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAccounts not implemented")
}
func (UnimplementedAccountsServiceServer) CreateAccount(context.Context, *CreateAccountRequest) (*CreateAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedAccountsServiceServer) GetAccountBalances(context.Context, *GetAccountBalancesRequest) (*GetAccountBalancesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAccountBalances not implemented")
}
func (UnimplementedAccountsServiceServer) PatchAccountLimits(context.Context, *PatchAccountLimitsRequest) (*PatchAccountLimitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PatchAccountLimits not implemented")
}
func (UnimplementedAccountsServiceServer) GetAccountByNumber(context.Context, *GetAccountByNumberRequest) (*GetAccountByNumberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAccountByNumber not implemented")
}
func (UnimplementedAccountsServiceServer) mustEmbedUnimplementedAccountsServiceServer() {}
func (UnimplementedAccountsServiceServer) testEmbeddedByValue()                         {}

// UnsafeAccountsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountsServiceServer will
// result in compilation errors.
type UnsafeAccountsServiceServer interface {
	mustEmbedUnimplementedAccountsServiceServer()
}

func RegisterAccountsServiceServer(s grpc.ServiceRegistrar, srv AccountsServiceServer) {
	// If the following call panics, it indicates UnimplementedAccountsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AccountsService_ServiceDesc, srv)
}

func _AccountsService_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsServiceServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountsService_ListAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsServiceServer).ListAccounts(ctx, req.(*ListAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsService_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsServiceServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountsService_CreateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsServiceServer).CreateAccount(ctx, req.(*CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsService_GetAccountBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsServiceServer).GetAccountBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountsService_GetAccountBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsServiceServer).GetAccountBalances(ctx, req.(*GetAccountBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsService_PatchAccountLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchAccountLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsServiceServer).PatchAccountLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountsService_PatchAccountLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsServiceServer).PatchAccountLimits(ctx, req.(*PatchAccountLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsService_GetAccountByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountByNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsServiceServer).GetAccountByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountsService_GetAccountByNumber_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsServiceServer).GetAccountByNumber(ctx, req.(*GetAccountByNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountsService_ServiceDesc is the grpc.ServiceDesc for AccountsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bank.accounts.v1.AccountsService",
	HandlerType: (*AccountsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAccounts",
			Handler:    _AccountsService_ListAccounts_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _AccountsService_CreateAccount_Handler,
		},
		{
			MethodName: "GetAccountBalances",
			Handler:    _AccountsService_GetAccountBalances_Handler,
		},
		{
			MethodName: "PatchAccountLimits",
			Handler:    _AccountsService_PatchAccountLimits_Handler,
		},
		{
			MethodName: "GetAccountByNumber",
			Handler:    _AccountsService_GetAccountByNumber_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bank/accounts/v1/accounts.proto",
}

const (
	InternalAccountsService_ValidateAccountsAndLimits_FullMethodName = "/bank.accounts.v1.InternalAccountsService/ValidateAccountsAndLimits"
	InternalAccountsService_ReserveHold_FullMethodName               = "/bank.accounts.v1.InternalAccountsService/ReserveHold"
	InternalAccountsService_ReleaseHold_FullMethodName               = "/bank.accounts.v1.InternalAccountsService/ReleaseHold"
	InternalAccountsService_BatchGetAccountSummaries_FullMethodName  = "/bank.accounts.v1.InternalAccountsService/BatchGetAccountSummaries"
)

// InternalAccountsServiceClient is the client API for InternalAccountsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// INTERNAL (para ledger/payments) - proteger con mTLS/API key
type InternalAccountsServiceClient interface {
	// POST /internal/accounts/validate
	ValidateAccountsAndLimits(ctx context.Context, in *ValidateAccountsAndLimitsRequest, opts ...grpc.CallOption) (*ValidateAccountsAndLimitsResponse, error)
	// POST /internal/accounts/{id}/hold/reserve
	ReserveHold(ctx context.Context, in *ReserveHoldRequest, opts ...grpc.CallOption) (*ReserveHoldResponse, error)
	// POST /internal/accounts/{id}/hold/release
	ReleaseHold(ctx context.Context, in *ReleaseHoldRequest, opts ...grpc.CallOption) (*ReleaseHoldResponse, error)
	BatchGetAccountSummaries(ctx context.Context, in *BatchGetAccountSummariesRequest, opts ...grpc.CallOption) (*BatchGetAccountSummariesResponse, error)
}

type internalAccountsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalAccountsServiceClient(cc grpc.ClientConnInterface) InternalAccountsServiceClient {
	return &internalAccountsServiceClient{cc}
}

func (c *internalAccountsServiceClient) ValidateAccountsAndLimits(ctx context.Context, in *ValidateAccountsAndLimitsRequest, opts ...grpc.CallOption) (*ValidateAccountsAndLimitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateAccountsAndLimitsResponse)
	err := c.cc.Invoke(ctx, InternalAccountsService_ValidateAccountsAndLimits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalAccountsServiceClient) ReserveHold(ctx context.Context, in *ReserveHoldRequest, opts ...grpc.CallOption) (*ReserveHoldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReserveHoldResponse)
	err := c.cc.Invoke(ctx, InternalAccountsService_ReserveHold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalAccountsServiceClient) ReleaseHold(ctx context.Context, in *ReleaseHoldRequest, opts ...grpc.CallOption) (*ReleaseHoldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseHoldResponse)
	err := c.cc.Invoke(ctx, InternalAccountsService_ReleaseHold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalAccountsServiceClient) BatchGetAccountSummaries(ctx context.Context, in *BatchGetAccountSummariesRequest, opts ...grpc.CallOption) (*BatchGetAccountSummariesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchGetAccountSummariesResponse)
	err := c.cc.Invoke(ctx, InternalAccountsService_BatchGetAccountSummaries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalAccountsServiceServer is the server API for InternalAccountsService service.
// All implementations must embed UnimplementedInternalAccountsServiceServer
// for forward compatibility.
//
// INTERNAL (para ledger/payments) - proteger con mTLS/API key
type InternalAccountsServiceServer interface {
	// POST /internal/accounts/validate
	ValidateAccountsAndLimits(context.Context, *ValidateAccountsAndLimitsRequest) (*ValidateAccountsAndLimitsResponse, error)
	// POST /internal/accounts/{id}/hold/reserve
	ReserveHold(context.Context, *ReserveHoldRequest) (*ReserveHoldResponse, error)
	// POST /internal/accounts/{id}/hold/release
	ReleaseHold(context.Context, *ReleaseHoldRequest) (*ReleaseHoldResponse, error)
	BatchGetAccountSummaries(context.Context, *BatchGetAccountSummariesRequest) (*BatchGetAccountSummariesResponse, error)
	mustEmbedUnimplementedInternalAccountsServiceServer()
}

// UnimplementedInternalAccountsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInternalAccountsServiceServer struct{}

func (UnimplementedInternalAccountsServiceServer) ValidateAccountsAndLimits(context.Context, *ValidateAccountsAndLimitsRequest) (*ValidateAccountsAndLimitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateAccountsAndLimits not implemented")
}
func (UnimplementedInternalAccountsServiceServer) ReserveHold(context.Context, *ReserveHoldRequest) (*ReserveHoldResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReserveHold not implemented")
}
func (UnimplementedInternalAccountsServiceServer) ReleaseHold(context.Context, *ReleaseHoldRequest) (*ReleaseHoldResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReleaseHold not implemented")
}
func (UnimplementedInternalAccountsServiceServer) BatchGetAccountSummaries(context.Context, *BatchGetAccountSummariesRequest) (*BatchGetAccountSummariesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchGetAccountSummaries not implemented")
}
func (UnimplementedInternalAccountsServiceServer) mustEmbedUnimplementedInternalAccountsServiceServer() {
}
func (UnimplementedInternalAccountsServiceServer) testEmbeddedByValue() {}

// UnsafeInternalAccountsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalAccountsServiceServer will
// result in compilation errors.
type UnsafeInternalAccountsServiceServer interface {
	mustEmbedUnimplementedInternalAccountsServiceServer()
}

func RegisterInternalAccountsServiceServer(s grpc.ServiceRegistrar, srv InternalAccountsServiceServer) {
	// If the following call panics, it indicates UnimplementedInternalAccountsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InternalAccountsService_ServiceDesc, srv)
}

func _InternalAccountsService_ValidateAccountsAndLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAccountsAndLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalAccountsServiceServer).ValidateAccountsAndLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalAccountsService_ValidateAccountsAndLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalAccountsServiceServer).ValidateAccountsAndLimits(ctx, req.(*ValidateAccountsAndLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalAccountsService_ReserveHold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReserveHoldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalAccountsServiceServer).ReserveHold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalAccountsService_ReserveHold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalAccountsServiceServer).ReserveHold(ctx, req.(*ReserveHoldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalAccountsService_ReleaseHold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseHoldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalAccountsServiceServer).ReleaseHold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalAccountsService_ReleaseHold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalAccountsServiceServer).ReleaseHold(ctx, req.(*ReleaseHoldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalAccountsService_BatchGetAccountSummaries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetAccountSummariesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalAccountsServiceServer).BatchGetAccountSummaries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalAccountsService_BatchGetAccountSummaries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalAccountsServiceServer).BatchGetAccountSummaries(ctx, req.(*BatchGetAccountSummariesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalAccountsService_ServiceDesc is the grpc.ServiceDesc for InternalAccountsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalAccountsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bank.accounts.v1.InternalAccountsService",
	HandlerType: (*InternalAccountsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateAccountsAndLimits",
			Handler:    _InternalAccountsService_ValidateAccountsAndLimits_Handler,
		},
		{
			MethodName: "ReserveHold",
			Handler:    _InternalAccountsService_ReserveHold_Handler,
		},
		{
			MethodName: "ReleaseHold",
			Handler:    _InternalAccountsService_ReleaseHold_Handler,
		},
		{
			MethodName: "BatchGetAccountSummaries",
			Handler:    _InternalAccountsService_BatchGetAccountSummaries_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bank/accounts/v1/accounts.proto",
}
